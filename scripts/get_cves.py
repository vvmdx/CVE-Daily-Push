# -*- coding: utf-8 -*-
# @Time    : 2024/1/3 10:56
# @Author  : vvmdx
# @File    : get_cves.py
# @Project : CVE-Daily-Push
import json
import re
import time
import urllib3
import json
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
# from config import NIST_API_KEY

NIST_API_KEY = ""

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

header = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    "Connection": "close"
}

retry = Retry(
    total=10,
    backoff_factor=1,
    method_whitelist=["GET"]
)


def get_cve(nist_api_key):
    global NIST_API_KEY
    NIST_API_KEY = nist_api_key
    cve_dict = get_cve_changes()
    if not cve_dict:
        return None
    """
    e.g.
    cve_dict = {
        'new_entries': [
            {'id': 'CVE-2022-34270', 'mitre': 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=2022-34270'},
            {'id': 'CVE-2023-27150', 'mitre': 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=2023-27150'}
        ],
        'modified_entries': [
            {'id': 'CVE-2021-41617', 'mitre': 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=2021-41617'},
            {'id': 'CVE-2023-27043', 'mitre': 'https://cve.mitre.org/cgi-bin/cvename.cgi?name=2023-27043'}
        ]}
    """
    # 计数，每40个休眠30秒，不然api获取不到内容
    count = 40
    for entries in cve_dict.values():
        for i in range(len(entries)):
            count -= 1
            tmp_dict = get_nvd_vul_details(entries[i]["id"])
            if tmp_dict:
                entries[i].update(tmp_dict)
            if count < 0:
                count = 40
                time.sleep(60)  # 很莫名奇妙的，用github actions跑的话不多延时一点，就会让api访问次数过多，然而本地没有这个问题，应该也是GitHub actions时间不准的锅
    cve_dict_json = json.dumps(cve_dict)
    print(cve_dict_json)
    return cve_dict

def get_cve_changes():
    """
    从url获得每天更新的cve列表（包含cve官网链接和cve编号）
    潜在的异常：当天没有新增和更新（真实存在）
    :return: 返回字典，两个key分别表示新发布的cve和已发布但是更新了的cve编号和对应的cve官网链接
    """
    url_ = "https://cassandra.cerias.purdue.edu/CVE_changes/today.html"
    # url_ = "https://cassandra.cerias.purdue.edu/CVE_changes/CVE.2024.01.03.html"
    adapter = HTTPAdapter(max_retries=retry)
    session = requests.Session()
    session.mount("https://", adapter)
    resp = session.get(url_, headers=header, verify=False)
    if resp.status_code == 200:
        resp_text = resp.text
        # 分割不同部分的cve列表
        # 当前已经不存在CAN前缀的漏洞编号了，所以不爬中间那个
        separator = "(.*?)Modified entries:(.*?)$"
        matches = re.search(separator, resp_text, re.DOTALL)
        new_entries = matches.group(1).strip()
        modified_entries = matches.group(2).strip()

        # 存在某天既没有新增也没有更新的可能性
        if not new_entries and not modified_entries:
            return None

        # 匹配cve编号和对应的url，将其分别对应到具体的分类
        entries_list = [new_entries, modified_entries]
        re_cve_list = re.compile("(?<=name=)[^'>]+")    # CVE id
        re_cve_url_list = re.compile("(?<=<A HREF = ')[^']+(?='>)")  # CVE链接
        re_cve_changes_list = re.compile("\(changes in (.*?);\)")  # CVE更新的地方
        # 设置为json格式
        entries_dict = {}
        for i in range(2):
            entries = entries_list[i]
            cve_list = ["CVE-" + id for id in re_cve_list.findall(entries)]
            cve_url_list = re_cve_url_list.findall(entries)
            # 写入字典
            tmp_dict = {}
            if cve_list:
                # i就0,1两个值
                if i:
                    cve_changes_list = re_cve_changes_list.findall(entries)

                    tmp_dict = {
                        "modified_entries": [{"id": id, "mitre": url, "changes": change}
                                             for id, url, change in zip(cve_list, cve_url_list, cve_changes_list)]}
                else:
                    tmp_dict = {"new_entries": [{"id": id, "mitre": url} for id, url in zip(cve_list, cve_url_list)]}
            entries_dict.update(tmp_dict)
        # print(entries_dict)
        return entries_dict


def get_nvd_vul_details(cve_id):
    """
    NVD提供的api，可以查询cve信息
    :param cve_id: CVE-2023-34829
    :return:
    """
    nist_api_key = NIST_API_KEY
    nvd_api_url = "https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={}".format(cve_id)
    # tenable_url = "https://www.tenable.com/cve/{}"
    nvd_header = header
    nvd_header["apiKey"] = nist_api_key
    adapter = HTTPAdapter(max_retries=retry)
    session = requests.Session()
    session.mount("https://", adapter)
    resp = session.get(nvd_api_url, headers=header, verify=False)
    if resp.status_code == 200:
        # 不一定每个cve都有详情(在nvd中不一定都能搜得到)，特别是新的洞
        if not json.loads(resp.text)["vulnerabilities"]:
            cve_detail_dict = {
                "vulnStatus": None,
                "descriptions": None,
                "references": [],
                "baseScore": None,
                "severity": None
            }
            return cve_detail_dict
        vul_details = json.loads(resp.text)["vulnerabilities"][0]["cve"]
        references = []
        for refs in vul_details["references"]:
            references.append(refs["url"])
        references = references

        print(vul_details["id"])

        # 翻译
        # description_cn = translate_(vul_details["descriptions"][0]["value"].replace("\\n", " "))

        cve_detail_dict = {
            "vulnStatus": vul_details["vulnStatus"],
            "descriptions": vul_details["descriptions"][0]["value"].replace("\\n", " "),
            # "descriptions": description_cn,
            "references": references
        }

        if len(vul_details["metrics"]) != 0:
            # metrics_dict = json.loads(vul_details["metrics"])
            # if metrics_dict
            cve_detail_dict["baseScore"], cve_detail_dict["severity"] = get_cvssMetric(vul_details["metrics"])
        else:
            cve_detail_dict["baseScore"], cve_detail_dict["severity"] = None, None
        return cve_detail_dict


def get_cvssMetric(metrics_dict):
    '''
    用于判断用了哪一套评分系统
    :return:
    '''
    check_keys = ["cvssMetricV31", "cvssMetricV30", "cvssMetricV2"]
    for key in check_keys:
        if key in metrics_dict:
            if key == check_keys[2]:
                return metrics_dict[key][0]["cvssData"]["baseScore"], metrics_dict[key][0]["baseSeverity"]
            else:
                return metrics_dict[key][0]["cvssData"]["baseScore"], metrics_dict[key][0]["cvssData"]["baseSeverity"]
    return None, None

# def translate_(description):
#     translator = Translate(proxies={'https': 'socks5://localhost:7890'})
#
#     return translator.translate(description).translatedText

